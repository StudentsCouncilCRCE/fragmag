---
index: 10
section: technical
title: Soaring Web Technologies
class: SE IT
author: Dhananjay Shettigar
endpoint: /soaring-web-technologies
---

Today, the greatest question an application developer probably faces in the early stages of their programming career is: Native or Web? For long, native applications built specifically to run on a particular Operating System and Web Apps built to run on the browser have had major differences with native apps leading in performance and stability while web apps enjoy multi-platform reach on a single codebase. Although with advancements in network technology and the amazing interest that web technologies have garnered, this line between native and web apps is starting to blur. The Open Source movement has had a massive impact on driving the progress of technology especially web technologies since these technologies are available the easiest and thus attract a bigger audience. Huge Silicon Valley companies use Open Source extensively in their development cycle since it helps produce applications faster, costs are reduced by a lot, developers work together to help each other and this in turn keeps feeding the flame that is Open Source. Open Source Web Technologies have gained massive contributions from the Mozilla Foundation, Google, Microsoft, Facebook and nearly every other big name in this technology space.

But how exactly have web apps been able to catch up to native applications? Generally speaking, native apps shine in providing direct hardware access, offline availability and crazy performance compared to traditional web apps. With modern applications requiring greater processing power and ease of use and accessibility becoming a must have for any app, it seems discouraging to develop a massive web application which is bound to fail pertaining to these reasons. But all hope is not lost. The Open Source community took it upon itself to make this happen. The vision was simple, to have people write code once, use anywhere without having to worry about any of the traditional drawbacks. There are 2 major relatively new technologies introduced to tackle these issues head on. Firstly, with modern browsers allowing web apps to store greater amounts of data than ever on the client side and providing easy-to-use APIs for direct hardware access, it was just a matter of providing a standard to create these hybrid apps using the code of a web app while possessing the offline features of a native app. These are PWAs or Progressive Web Apps. Second, and the most difficult hurdle with web apps which is performance has been the biggest turn off to developers thinking of moving to web app development. To deal with this, the W3C (World Wide Web Consortium) has added a new language to the recommended native browser support languages which previously included only HTML, CSS and JavaScript.

Let’s have a look at PWAs first. Progressive Web Apps are exactly what they sound like. The progress of technology has allowed their existence to come into being. Progressive Web Apps harness the power provided by modern browsers (majorly Chromium project by Google, another open source product) to establish client-side storage for crucial components of an app which may take a longer time to be transferred over the network over and over again and also establish core offline functionalities such as push notifications, offline data persistence and more interactive native-like interfaces. PWAs are not only the subset of web apps which take advantage of client-side storage but they are also built using the best practices in web development. PWAs force HTTPS to be able to utilise HTTP/2 which is a more efficient and secure transport protocol allowing greater speeds without compromising on data integrity using binary framing layers encapsulating HTTP semantics as opposed to HTTP’s plain text format. Desktop Browsers allow up to 500mb while mobile browsers are capped at 10mb of client-side storage capacity and so PWAs are made responsive keeping these limitations in mind. But since web apps use languages which were designed to cost less storage and using compressed assets to save network round trip times, PWAs were set up for success even before being introduced back in 2015. PWAs in general use the PRPL Pattern as guideline for maximum efficiency. PRPL is Push or Preload critical resources for initial URL Route, Render initial route, Pre-cache remaining routes, Lazy-load and create remaining routes on demand. Preloading is used to prioritize loading certain files in your app without which your app does not reach its initial view or landing page. This is done by adding the declarative fetch attribute of ‘rel = “preload”’ to link tags. Rendering the initial route refers to the first bit of processing that your app needs usually written in JavaScript. You can add non-crucial JavaScript operations to a different file which can be deferred using “async” for an asynchronous load pattern. Pre-caching is keeping a cache of assets used in your app on first load so that the service workers in your browser can act as a proxy fetching the cached assets instead of pulling resources from the server on every request. Finally, Lazy-load is a relatively new technique brought about by web bundlers such as webpack which allow splitting your dependencies into chunks which can be loaded on demand. For example, you would only request pulling axios, a wonderful http client API only when you actually submit the form which needs the library to function. Thus, all of these minor things work toward having a blazing fast first paint or initial render of your web app by reducing the amount of data sent over the network and the initial processing done on the client side allowing to pave the way for growth of PWAs further.

Next, we come to the performance issue. Let’s get into it with a backstory. A few years ago, Mozilla saw this potential in the web, the very thing this article is based on. The developers at Mozilla thought they were limited by their JavaScript engine performance and as such came up with a framework called asm.js which was supposed to be a low-level subset of JavaScript. They had the idea that browsers would see the special string designed for asm.js and switch to a super-fast JavaScript engine and they released it to the public. Google being the big bad bowser king, was expected to add asm.js support to their browser Chrome. But the folks at google were like why don’t we just make the regular JavaScript engine faster and they did it and essentially succeeded to make the performance boost provided by asm.js a miniscule one. (Personally, I just think it’s really cool/kickass how Mozilla came up with this new idea and Google was just like “Hold my beer”). Now the problem with this approach was that the end result was still JavaScript and there are only so many optimizations you can make to the core functionalities of a language. Well that was before WASM was brought into picture. WASM short for Web Assembly is an Assembly Level language for the browser. If you had to draw comparisons, WASM code is like the bytecode generated by Java compilers which can run on any JVM irrespective of the platform it is running on with relatively the same speed. Here your browser is the JVM equivalent. WASM is a compile target meaning you write your code in a language you feel comfortable in and then you can leave it up to the compiler to provide you with a final product in form of a WASM bytecode. WASM was first developed keeping low level languages in mind since they provide the most granular access to OS level features which help performance most. As such, C++ was the first language to be compiled into WASM. Today, WASM supports nearly all languages under the LLVM (Low Level Virtual Machine) umbrella including Rust, Swift, Clang and more. Rust has been particularly interesting in the web field. Rust has seen tremendous progress in performant, reliable code and with syntax taking cues from high level languages while still being a low-level systems language, Rust is now used in compilers creating the WASM binaries. Mozilla has been heavily pushing Rust as a memory safe language having replaced a lot of C++ code in their browser with Rust but that is outside the scope of this article. All I can say is Rust may just become the next C++ :P

If anything, this web movement is better late than never. Apple had the opportunity to fast- track this in the days of the launch of the first iPhone. When asked about app development for the iPhones, Steve Jobs said he expects developers to create web apps. But there wasn’t a whole lot of developers coming up with any ideas and in the end, Apple crumbling under pressure, decided to go with the creation of the app store and the entirety of the ugly iOS development environment. Well, all of that to say the future of the Web is bright and we may very well see more web apps being developed using low level languages harnessing every bit of power provided by the hardware, the permissions provided by the OS and the optimizations provided by the Browser. You can check out Mozilla’s vision for the future of WASM at hacks.mozilla.org in the “Web Assembly Post MVP Future” article. Thanks for reading!
